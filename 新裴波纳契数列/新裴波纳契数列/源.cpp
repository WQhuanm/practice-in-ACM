#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include<string.h>

//题目要求输入的N为N<1 000 000，而斐波那契数列增长的非常快，因此不能采用先算出F(n)的方法，然后再对3取模
//即 F(n) %3 = (F(n-1) + F(n-2) ) %3，此式子由数论取模知识易知可以进一步等价于 F(n) %3 = (F(n-1) %3 + F(n-2) %3) %3。,n通式有规律，说明整个有循环规律，现在我们开始找规律：
//F(0)%3=1，F(1)%3=2，F(2)%3=(F(1)%3+F(0)%3)%3=0，同理 F(3)%3=2，F(4)%3=2，F(5)%3=1，F(6)%3=0，F(7)%3=1，F(8)%3=1，F(9)%3=2
//，这时可以发现 F(0)%3=1，F(1)%3=2 ，又 F(8)%3=1，F(9)%3=2，表明此时已出现循环，即一个完整的循环为：
//{1，2，0，2，2，1，0，1}，既然已经出现了循环，那么此题就可以划为找规律题目了，此问题就迎刃而解了





//补充，取模运算
//(a + b) % p = (a % p + b % p) % p （1）     //原理，左边%p=((k1*p+r1)+(k2*p+r2))%p,           (k1*p+r1)=a,(k2*p+r2)=b
//(a - b) % p = (a % p - b % p) % p （2）               //k*p会直接被模p约掉，所以加了也是白加，可以删，所以 ((k1*p+r1)+(k2*p+r2))%p=((k1+k2)*p+(r1+r2))%p=(r1+r2)%p
//(a * b) % p = (a % p * b % p) % p （3）
//a ^ b % p = ((a % p) ^ b) % p （4）

int main() {
	int f[8] = { 1,2,0,2,2,1,0,1 };  //下标0到7
	int n;
	while (scanf("%d", &n) == 1) {
		if (f[n % 8] == 0) {
			printf("yes\n");
		}
		else
			printf("no\n");
		
	}


	return 0;
}