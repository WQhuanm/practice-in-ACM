#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include<string.h>
#include<algorithm>
using namespace std;


//
//小老鼠准备了M磅的猫粮，准备去和看守仓库的猫做交易，因为仓库里有小老鼠喜欢吃的五香豆。
//仓库有N个房间；
//第i个房间有J[i] 磅的五香豆，需要用F[i]磅的猫粮去交换；
//需要指出的是：
//1、老鼠如果要和某个房间的猫做交易，就必须交换该房间所有的五香豆！
//2、还有个特殊的情况，小老鼠有强迫症――它一定要把自己所有的猫粮都用完才行！
//现在，请帮忙计算一下，在必须用完所有的猫粮的前提下，小老鼠通过交易最多能够得到多少磅的五香豆？
//Input
//输入包含多组测试用例。
//每组测试数据首先一行是2个非负整数M和N，接着的N行，每行分别包含2个非负整数J[i]和F[i]，数据的具体含义详见题目描述。
//输入数据以两个 - 1结束。
//题目保证所有的数据都不超过1000.
//Output
//请计算并输出小老鼠最多能够得到的五香豆数量，如果不能满足小老鼠的强迫症，请输出 - 1；



//
//
//int dp[1100][1100];  //表示i间房间j猫粮可以获取最大豆子
//int j[1100];//豆子
//int f[1100];  //猫粮
//int arr[1100][1100];  //arr[i][j]用于判断i间房间时拥有j猫粮（必须限定i房间时，不然与其他i情况冲突）是不是空间装满
//
//int main() {
//	int M, N;
//	while (scanf("%d %d", &M, &N) == 2 && (M != -1 || N != -1)) {
//		memset(dp, 0, sizeof(dp));
//		memset(j, 0, sizeof(j));
//		memset(f, 0, sizeof(f));
//		memset(arr, -1, sizeof(arr));   //猫粮没有用完就不为0，所以初始化为-1
//		for (int i = 0; i <= N; i++) {   //初始化猫粮为0时空间剩余0
//			arr[i][0] = 0;
//		}
//		for (int i = 1; i <= N; ++i)scanf("%d %d", &j[i], &f[i]);
//		
//		for (int i = 1; i <= N; ++i) {
//			for (int k = 0; k <= M; ++k) {
//				if (k < f[i]) {     //猫粮不够换，那么跟i-1间房间情况一样
//					dp[i][k] = dp[i - 1][k];
//					if (arr[i - 1][k] == 0)arr[i][k] = 0;
//				}
//				else
//				{
//					if (arr[i - 1][k - f[i]] == 0)   //表示第i-1间房间猫粮用完下，这样我第i间房间需要猫粮为f[i]（前i间房间已经用去k - f[i]），保证猫粮在第i间也刚刚好用完
//					{
//						dp[i][k] = max(dp[i - 1][k], dp[i - 1][k - f[i]] + j[i]);
//						arr[i][k] = 0;  //更新i间房间拥有k猫粮时可以全部用完
//					}
//					else {
//						dp[i][k] = dp[i - 1][k];   //如果第i-1间房间猫粮不能用完，那我第i间房间装换猫粮肯定有剩余，那么我就不换了
//						if (arr[i - 1][k] == 0)arr[i][k] = 0;   //但我不能保证dp[i - 1][k]一定是装满的，所以只有他装满（即arr[i - 1][k] == 0）我才让arr[i][k] = 0;也表示装满
//					}
//				}
//			}
//		}
//		if (arr[N][M] == 0)printf("%d\n", dp[N][M]);
//		else printf("-1\n");
//	}
//	return 0;
//}
//
//




                //优化版（一维）

int dp[1100];  //表示k空间的猫粮可以获得最大的豆子，并不需要第几间房间
int j[1100];//豆子
int f[1100];  //猫粮

int main() {
	int M, N;
	while (scanf("%d %d", &M, &N) == 2 && (M != -1 || N != -1)) {
		memset(dp, -1, sizeof(dp));    //全部赋值-1
		memset(j, 0, sizeof(j));
		memset(f, 0, sizeof(f));
		dp[0] = 0;   //只有0赋值为0，因为0猫粮就是0
		for (int i = 1; i <= N; ++i)scanf("%d %d", &j[i], &f[i]);

		for (int i = 1; i <= N; ++i) {
			for (int k = M; k >= f[i]; --k) {   //反着推解决后效性问题，保证每一个i的第一个k（即M）比较的 dp[k - f[i]]中的值都是没有插入新一轮j【i】的
				if (dp[k - f[i]] >= 0)   //只有大于等于0（等于0就是dp[0])的数（即属于装满的数）才会被加入，即前面的必定是已经装满的数
					dp[k] = max(dp[k], dp[k - f[i]] + j[i]);
			}
		}
		if (dp[M] >= 0)printf("%d\n", dp[M]);   //要大于等于，等于防他说不定刚刚好就是dp[0]
		else printf("-1\n");

	}
	return 0;
}
