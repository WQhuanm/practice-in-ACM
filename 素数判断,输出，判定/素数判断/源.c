#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include<string.h>
#include<math.h>

                 //素数的判断
	int judge(int n)     //6x素数法
	{                                     //首先（1），一个合数必定可由其平方根相乘得到，或者一个大于，一个小于平方根的数得到，利用这个思想，只需考虑是否可以除去平方根一边的数，可以则另一半绝对可以
		if (n < 5)                       //其次，可以被除，那就是合数，不是素数 
		{                                 //接着，一个结论，在6*n相邻左右边的首先都是奇数，所以有可能是素数，而不是相邻绝对不是素数，因为6*n+(-)2==2*(3*n+(-)1),或者6*n+(-)3==2*(3*n+(-)1),4也是同理
			if (3 == n || 2 == n)                 //6这个可以有2与3乘出的数非常特殊，所以只有6*n相邻左右才可能为素数（素数一定在6*n左右），其余都可以约分（合数），所以讨论可以以6的倍数来讨论
				return 1;                 //6n的左右就是余数1或者5（0或者6的左右），所以以1或者5为起点不断+6，减少计算量（实际只要一个，如5+2就是得1（因为7-6=1）
			else                          //然后，除了本身和1，任何数都不是因数（包括其他素数），所以不断缩小可能因数范围来减少计算量，即奇数，更直接，有可能为素数的奇数（这样极大缩小范围）
				return 0;
		}         //6之前先分开讨论，后面直接循环

		else
		{
			if (n % 6 != 1 && n % 6 != 5)   //这里说明不是相邻全部滚蛋
				return 0;
			else
			{                                //这里讨论与6*n相邻的奇数们，来判断是不是素数
				for (int j = 5; j <= sqrt(n); j += 6)      //由（1），只需讨论5到平方根的j（这些j是最有可能为素数的奇数，如果他们都不能被除，那么n为素数）有没有可能为n的因数就好，每个循环加6
				{                                         
					if (0 == n % j || 0 == n % (j + 2))                //如果n（目标）可以被6*n相邻的这个奇数整除，说明不止俩根，舍去，如果不能除，j不断增加，到了平方根时，因为int所以素数平方根被砍去一些
						return 0;                                      //到了平方根还不能整除，说明平方根本来不是整数（被int砍了），则n就是素数了
				}     //j从5开始，俩种可能，一种余数为5（在6左边的j），一种余数为1（6的右边），都要写，否则省略了一些素数（一些可能的因数）
				return 1;
			}
		}
	int main()
	{
		int C;
		scanf("%d", &C);
		for (int i = 0; i < C; i++)
		{
			int x;
			scanf("%d", &x);
			int a=judge(x);
			if ( 1==a)
				printf("YES\n");
			if (0 == a)
				printf("NO\n");
		}
		return 0;
	}































