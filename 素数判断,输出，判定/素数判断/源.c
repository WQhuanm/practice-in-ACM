#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include<string.h>


//  #include<math.h>               //素数的判断
//int judge(int n)     //6x素数法
//{                                     //首先（1），一个合数必定可由其平方根相乘得到，或者一个大于，一个小于平方根的数得到，利用这个思想，只需考虑是否可以除去平方根一边的数，可以则另一半绝对可以
//	if (n < 5)                       //其次，可以被除，那就是合数，不是素数 
//	{                                 //接着，一个结论，在6*n相邻左右边的首先都是奇数，所以有可能是素数，而不是相邻绝对不是素数，因为6*n+(-)2==2*(3*n+(-)1),或者6*n+(-)3==2*(3*n+(-)1),4也是同理
//		if (3 == n || 2 == n)                 //6这个可以有2与3乘出的数非常特殊，所以只有6*n相邻左右才可能为素数（素数一定在6*n左右），其余都可以约分（合数），所以讨论可以以6的倍数来讨论
//			return 1;                 //6n的左右就是余数1或者5（0或者6的左右），所以以1或者5为起点不断+6，减少计算量（实际只要一个，如5+2就是得1（因为7-6=1）
//		else                          //然后，除了本身和1，任何数都不是因数（包括其他素数），所以不断缩小可能因数范围来减少计算量，即奇数，更直接，有可能为素数的奇数（这样极大缩小范围）
//			return 0;
//	}         //6之前先分开讨论，后面直接循环
//
//	else
//	{
//		if (n % 6 != 1 && n % 6 != 5)   //这里说明不是相邻全部滚蛋
//			return 0;
//		else            //剩下都是6n附近的数才会进入else判断是否为素数
//		{                                //这里讨论与6*n相邻的奇数们，来判断是不是素数
//			for (int j = 5; j <= sqrt(n); j += 6)      //由（1），只需讨论5到平方根的j（这些j是最有可能为素数的奇数，如果他们都不能被除，那么n为素数）有没有可能为n的因数就好，每个循环加6
//			{
//				if (0 == n % j || 0 == n % (j + 2))                //如果n（目标）可以被6*n相邻的这个奇数整除，说明不止俩根，舍去，如果不能除，j不断增加，到了平方根时，因为int所以素数平方根被砍去一些
//					return 0;                                      //到了平方根还不能整除，说明平方根本来不是整数（被int砍了），则n就是素数了
//			}     //j从5开始，俩种可能，一种余数为5（在6左边的j），一种余数为1（6的右边），都要写，否则省略了一些素数（一些可能的因数）
//			return 1;             //没有进入for循环的（n小于25时）或者坚持到for循环结束的，返回1
//		}
//	}
//}
//	int main()
//	{
//		int C;
//		scanf("%d", &C);          //C组数据
//		for (int i = 0; i < C; i++)
//		{
//			int x;
//			scanf("%d", &x);
//			int a = judge(x);
//			if (1 == a)
//				printf("YES\n");
//			if (0 == a)
//				printf("NO\n");
//		}
//		return 0;
//	}
//
//
//#include<math.h>
//                       //素数输出
//void judge(int n)
//{
//	if (n < 5)
//	{
//		if (2 == n || 3 == n)
//			printf("%d ", n);
//	}
//	else
//	{
//		if (n % 6 == 1 || n % 6 == 5)
//		{
//			for (int i = 5; i <= sqrt(n); i += 6)
//			{
//				if (n % i == 0 || n % (i + 2) == 0)
//					goto ABC;
//			}
//			printf("%d ",n);
//		}   ABC:;
//	}
//
//}
//
//int main()
//{
//	int N;
//	while (scanf("%d", &N) != EOF)
//	{
//		for (int a = 2; a <= N&&a<5; a++)
//		{
//			if(a==3 ||a==2 )
//				printf("%d ", a);
//	}
//		for (int j = 1; j <= N ; j += 6)
//		{
//			judge(j);
//			if (j + 4 <= N)
//				judge(j + 4);
//		}
//		printf("\n");
//
//	}
//
//
//
//	return 0;
//}
//

#include<math.h>       //素数判定
int judge(int n)             //判断是否为素数的函数（孪生素数法）
{
    if (n < 5)
    {
        if (n == 2 || n == 3)
            return 1;
        else
            return 0;
    }
    else
    {
        if (n % 6 != 1 && n % 6 != 5)
            return 0;
        else
        {
            for (int i = 5; i <= sqrt(n); i += 6)
                if (0 == n % i || 0 == n % (i + 2))
                {
                    return 0;
                }

            return 1;
        }
    }
}

int main()
{
    int x, y,n,m,b;
    while (scanf("%d %d", &x, &y) != EOF) //x<=n<=y
    {
        if (x == 0 && y == 0)
            break;
        else
        {
            for (int n = x; n <= y; n++)
            {
                m = n * n + n + 41;              //n的表达式值为m
                b=judge(m);
                if (b == 0)                   //有一个判断不为素数，输出sorry并跳出for循环，进入while循环测试下一组数据，一直没有就跑到循环结束，成功输出ok并进入下一组数据
                {
                    printf("Sorry\n");
                    goto ABC;
                }
            }
            printf("OK\n");
        ABC:;
        }
    }



    return 0;
}



































